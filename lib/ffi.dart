// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Owlchat Crypto Binding
class RawOwlchatCrypto {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RawOwlchatCrypto(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RawOwlchatCrypto.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Destroy the crypto library, freeing all memory.
  ///
  /// This function must be called before the application exits.
  /// It is **NOT** safe to call this function multiple times.
  ///
  /// # Examples
  ///
  /// ```
  /// use owlchat_crypto::*;
  ///
  /// assert_eq!(unsafe { owlchat_crypto_destory() }, OwlchatResult::NotInitialized);
  /// assert_eq!(unsafe { owlchat_crypto_init() }, OwlchatResult::Ok);
  /// assert_eq!(unsafe { owlchat_crypto_destory() }, OwlchatResult::Ok);
  /// ```
  ///
  /// # Errors
  ///
  /// This function will return an error if Keypair is not initialized yet.
  ///
  /// # Safety
  ///
  /// Calling this function will deallocate the [crypto::KeyPair] and remove it from the memory
  /// so calling it, while the [crypto::KeyPair] is still in use, will cause undefined behavior.
  int owlchat_crypto_destory() {
    return _owlchat_crypto_destory();
  }

  late final _owlchat_crypto_destoryPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'owlchat_crypto_destory');
  late final _owlchat_crypto_destory =
      _owlchat_crypto_destoryPtr.asFunction<int Function()>();

  /// This a Dart FFI interface to be called inside an Isolate.
  ///
  /// Passing a Isolate Port, along with some Protobuf payload, to this function will
  /// process the payload and return the result to the isolate over the port.
  ///
  /// # Errors
  ///
  /// This function will return an error if the provided payload is not valid.
  ///
  /// # Safety
  ///
  /// This function is unsafe because it deals with raw pointers.
  int owlchat_crypto_dispatch(
    int port,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _owlchat_crypto_dispatch(
      port,
      data,
      len,
    );
  }

  late final _owlchat_crypto_dispatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int64, ffi.Pointer<ffi.Uint8>,
              uintptr_t)>>('owlchat_crypto_dispatch');
  late final _owlchat_crypto_dispatch = _owlchat_crypto_dispatchPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Initialize the crypto library.
  ///
  /// This function must be called before any other crypto function.
  /// It is **NOT** safe to call this function multiple times.
  /// # Examples
  ///
  /// ```
  /// use owlchat_crypto::*;
  ///
  /// assert_eq!(unsafe { owlchat_crypto_init() }, OwlchatResult::Ok);
  /// ```
  ///
  /// # Errors
  ///
  /// This function will return an error if the [crypto::KeyPair] is already initialized.
  ///
  /// # Safety
  ///
  /// Should be only called once during the lifecycle of the application.
  int owlchat_crypto_init() {
    return _owlchat_crypto_init();
  }

  late final _owlchat_crypto_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('owlchat_crypto_init');
  late final _owlchat_crypto_init =
      _owlchat_crypto_initPtr.asFunction<int Function()>();
}

abstract class OwlchatResult {
  static const int Ok = 1;
  static const int NotInitialized = 2;
  static const int AlreadyInitialized = 3;
  static const int NullPointerDetected = 4;
  static const int InvalidProtobuf = 5;
}

typedef uintptr_t = ffi.Uint64;
